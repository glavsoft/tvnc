
let project_folder = "dist";                                     //создаем переменные на и присваеваем название папки на случай если захотим изменить имя папки
let source_folder = "#src";                                      //создаем переменные на и присваеваем название папки на случай если захотим изменить имя папки


let path = {
    //ниже указываем пути хранения файлов при билде(сборке), где у нас в папке, будет соблюдаться иерархия, html в корне
    //стили в папке css и так далее.
    build: {
        html: project_folder + "/",
        css: project_folder + "/css/",
        js: project_folder + "/js/",
        img: project_folder + "/img/",
        fonts: project_folder + "/fonts/",
    },
    //ниже указываем пути хранения файлов исходников(папка с исходникамии, исходная папка), где у нас в папке, будет соблюдаться иерархия, html в корне
    //и так далее.
    src: {
        html: [source_folder + "/*.html", "!" + source_folder + "/_*.html"],    //что бы файл html создавался только один необходимо к всем именам в исходной папке короме index.html добавлять плинтус _ и в этой строке создаем массив и добавляем исключение что бы в папку назначения не копировались файлы с началом имени плинтус _ . В массиве вначале все файлы считывает, а затем исключает имена файлов которые начинаются с _
        css: source_folder + "/scss/style.scss",                        //указываем конкретный файл .scss что бы галп не обрабатывал все файлы а только конкретный style.scss который в себе будет собирать все подключенные файлы .scss
        js: source_folder+ "/js/script.js",                             //аналогично стилям.
        img: source_folder + "/img/**/*.{jpg,png,svg,gif,ico,webp}",    // что бы галп слушал все папки и подпапки которые находятся внутри img мы указываем слудующее ** эти звездочки. Далее *.{jpg,png,svg,gif,ico,webp}" указав конкретные расширения файлов что бы галп слушал только их исключая тем самым поподания других расширений файлов
        fonts: source_folder + "/fonts/*.ttf",                          //Галп будет слушать только фалый с любым именем но расширением *.ttf
    },
    //ниже еще создадим один объект который будет содержать в себе пути к фалам которые нам нужно слушать постоянно
    //отлавливать их изменения и сразу что то на лету выполнять
    watch: {
        html: source_folder + "/**/*.html",                             //слушаем все дочерние папки и только те файлы которые именют разширение .html
        css: source_folder + "/scss/**/*.scss",
        js: source_folder+ "/js/**/*.js",                               //аналогично
        img: source_folder + "/img/**/*.{jpg,png,svg,gif,ico,webp}",
    },
    //создаем еще один объект который содержит путь к папки проекта, этот объект будет отвечать за удаление этой папки
    //кадый раз когда мы будем запускать галп
    clean: "./" + project_folder + "/"
}

//зоздадим еще ряд переменных которые помогут в написании сценария
let {src, dest} = require('gulp'),                                      //это 2 переменные к оторым будет присвоен сам галп
    gulp = require('gulp'),                                             //еще переменная gulp к которой присвоим сам галп для выполнения каких то отдельных задач далее этот список переменных будет увеличиваться по мере того как мы будем устанавливать различные плагины и дополнения. При установке плагинов пишем --sev-dev что бы сохранялись версии пакетов
    browsersync = require('browser-sync').create(),                     //browser-sync это плагин который будет обнавлять нашу страницу как типа живая перезагрузка npm i browser-sync --save-dev
    fileinclude = require('gulp-file-include'),                         //к перем fileinclude присваиваем сам плагин. Это пакет который служет для того что бы к примеру htm файл собирался из разных отдельных блоков апример разделить на 3 файла header main footer а собралось все в index.html
    del = require('del'),                                               //пакет для удаления папки
    scss = require('gulp-sass'),                                        //после установки npm gulp-sass можем обявить перем scss
    autoprefixer = require('gulp-autoprefixer'),                        //первое что делаем после установки пакета это объявляем переменную
    group_media = require('gulp-group-css-media-queries'),              //данный npm груперует медиа запросы разбросанные по css файлу и добавляет их вконце
    clean_css = require('gulp-clean-css'),                               //чистит и сжимает наш css файл на выходе в данном случает для min.style.css
    rename = require('gulp-rename'),                                     //переименовывает фал из style.css в min.style.css
    uglify = require('gulp-uglify-es').default,                          //сжатие и оптимизация js
    babel = require('gulp-babel'),                                       //поддержка кода js для старых браузеров
    imagemin = require('gulp-imagemin'),                                  //ужиматель картинок и оптимизатор без потери качкства
    ttf2woff = require('gulp-ttf2woff'),
    ttf2woff2 = require('gulp-ttf2woff2');

//далее создаем отдельную функцию которая и будет обновлять нашу страницу
function browserSync(params) {
    browsersync.init({                                                  //здесь пишим некоторые настройки плагина
        server: {
            baseDir: "./" + project_folder + "/"                        //здесь указывается базовая папка откуда и будет осуществляться отображение в браузере. Значение такое же как для переменной clean
        },
        port: 3000,                                                     //порт по которому будет открываться браузер
        notify: false                                                   //убирает табличку которая присутствует в браузере (типа браузер обновился или что то в этом роде)
    })
}

//создадим функцию для работы с html файломи
function html() {
    return src(path.src.html)                                            //ф-я будет возвращать перем src, внутри переменной укажим путь к исходным файлам которые находятся в объекте path
        .pipe(fileinclude())                                                //тут мы попросим галп наши html файлы собирать. для этого просто обратимся к нашей перем fileinclude
        .pipe(dest(path.build.html))                                      //pipe это ф-я в которой мы пишим комманды для галпа. Сейчас тут просто галп перекопирует файлы и папки которые лежат в исходной папке в папку назначения
        .pipe(browsersync.stream())                                       //ф-я stream нужна что бы после каждого перекопирования файлов (описано в строке выще) необходимо что бы галп обновил страницу
}

//создадим функцию для работы с css файломи
function css() {
    return src(path.src.css)                                            //ф-я будет возвращать перем src, внутри переменной укажим путь к исходным файлам которые находятся в объекте path
        .pipe(                                                          //добавляем обработку
            scss({                                              //сдесь указываем различные настрокий
                outputStyle: "expanded"                                 //данная настрока указывает то бы файл css не как не сжимался а был удобочитаемым
            })
        )
        .pipe(
            group_media()
        )
        .pipe(                                                           //второе добавляем autoprefixer в задачи выполнения
            autoprefixer({                                         //настройки
                overrideBrowserslist: ["last 5 versions"],                 //поддерживаемые браузеры последние 5 версий
                cascade: true                                               //стиль написания автопревиксера а именно в данном случае каскадный
            })
        )
        .pipe(dest(path.build.css))
        .pipe(clean_css())                                                //сжимаем файл стилей
        .pipe(
            rename({                                                //переименовываем файл
                extname: ".min.css"                                         //будет style.min.css
            })

        )
        .pipe(dest(path.build.css))                                      //pipe это ф-я в которой мы пишим комманды для галпа. Сейчас тут просто галп перекопирует файлы и папки которые лежат в исходной папке в папку назначения
        .pipe(browsersync.stream())                                       //ф-я stream нужна что бы после каждого перекопирования файлов (описано в строке выще) необходимо что бы галп обновил страницу
}

//создадим функцию для работы с js файломи
function js() {
    return src(path.src.js)                                            //ф-я будет возвращать перем src, внутри переменной укажим путь к исходным файлам которые находятся в объекте path
        .pipe(fileinclude())                                                //тут мы попросим галп наши js файлы собирать. для этого просто обратимся к нашей перем fileinclude
        .pipe(                                                          //если расположить сдесь то преобразует как файл .js так и файл min.js если нужно преобразовать только min.js то расположить под строкой .pipe(dest(path.build.js))
            babel({
                presets: ['@babel/env']
            })
        )
        .pipe(dest(path.build.js))                                      //pipe это ф-я в которой мы пишим комманды для галпа. Сейчас тут просто галп перекопирует файлы и папки которые лежат в исходной папке в папку назначения
        .pipe(
            uglify()
        )
        .pipe(
            rename({                                                //переименовываем файл
                extname: ".min.js"                                         //будет script.min.js
            })
        )
        .pipe(dest(path.build.js))                                       //pipe это ф-я в которой мы пишим комманды для галпа. Сейчас тут просто галп перекопирует файлы и папки которые лежат в исходной папке в папку назначения
        .pipe(browsersync.stream())                                       //ф-я stream нужна что бы после каждого перекопирования файлов (описано в строке выще) необходимо что бы галп обновил страницу
}

//создадим функцию для работы с images файломи
function images() {
    return src(path.src.img)                                            //ф-я будет возвращать перем src, внутри переменной укажим путь к исходным файлам которые находятся в объекте path
        .pipe(
            imagemin({
                progressive: true,
                svgoPlugins: [{ removeViewBox: false }],                //работа с svg изображениями
                interlaced: true,
                optimizationLevel: 3                                    //0 to 7    данная настройка указыват на качество изображения
            })
        )
        .pipe(dest(path.build.img))                                      //pipe это ф-я в которой мы пишим комманды для галпа. Сейчас тут просто галп перекопирует файлы и папки которые лежат в исходной папке в папку назначения
        .pipe(browsersync.stream())                                       //ф-я stream нужна что бы после каждого перекопирования файлов (описано в строке выще) необходимо что бы галп обновил страницу
}

//создадим функцию для работы с шрифтами
function fonts(params) {
    src(path.src.fonts)
        .pipe(ttf2woff())
        .pipe(dest(path.build.fonts));
    return src(path.src.fonts)
        .pipe(ttf2woff2())
        .pipe(dest(path.build.fonts));
}

//создадим функцию которая будет слидить за нашими изменениями в режиме реального времени (отлавливать изменения на лету)
function watchFiles(params) {
    gulp.watch([path.watch.html], html);                              //в круглых скобках указываем путь к той папке за файлами которой нужно следить, прописывали выше в объекте path. Далее нашу функцию watchFile указываем в сценарии выполения ниже
    gulp.watch([path.watch.css], css);
    gulp.watch([path.watch.js], js);
    gulp.watch([path.watch.img], images);
}

//ниже созадим функцию которая будет чистить удалять папку назначения (папку dist)
function clean(params) {
    return del(path.clean);                                                              //указываем путь к папке. Ниже в сценарии не забываем добавить к переменной build нашу функцию clean
}

//что бы проверить работоспособность в галп необходимо еще создать переменные
//ф-я готова но теперь ее нужно подружить с галпом и включить в процес выполнения
let build = gulp.series(clean, gulp.parallel(js, css, html, images, fonts));                                   //здесь внури в круглых скобках будем прописывать ф-и которые дожны выполняться. Вначале папка будет удаляться ф-я clean, затем будет выполняться ф-я html
let watch = gulp.parallel(build, watchFiles, browserSync);                                  //к переменной watch присоем галп внутри укажем выполнение функции browserSync

//теперь нужно подружить галп с новыми переменными что бы он их понимал и мог с ними работать для этого используется exports
exports.fonts = fonts;
exports.images = images;
exports.js = js;
exports.css = css;                                                      //обязательно подружить галп с новой переменной css
exports.html = html;                                                    //обязательно подружить галп с новой переменной html
exports.build = build;
exports.watch = watch;                                                 //
exports.default = watch;                                                //когда мы запускаем гал то выполняется эта переменная по умолчанию и будет выполняться watch которая в свою очередь будет запускать browserSync